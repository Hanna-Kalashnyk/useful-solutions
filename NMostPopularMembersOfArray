//The program should output n most popular shows' ids from an array of show serias' ids.
//Example: [1,1,1,3,4,2,2] and n=2 should output [1, 2]
import java.util.*;

public class NMostPopularMembersOfArray {
    public static void main(String[] args) {
        int[] showIds = {1, 1, 1, 3, 4, 2, 2};
        int n = 2;
        int[] mostPopularShows = findNPopularIdsThroughPriorityQueue (showIds, n);
        System.out.println(Arrays.toString(mostPopularShows));

        int[] mostPopularShows = findNPopularIdsThroughSortedArray (showIds, n);
        System.out.println(Arrays.toString(mostPopularShows));
    }

    public static int[] findNPopularIdsThroughPriorityQueue(int[] showIds, int n) {
        Map<Integer, Integer> countMap = new HashMap<>();

        // Count the frequency of each show series id
        for (int id : showIds) {
            countMap.put(id, countMap.getOrDefault(id, 0) + 1);
        }

        // Sort the enntries of HashMap by frequency in descending order
        PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());
        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {
            queue.offer(entry);
        }
        int[] popularIds = new int[n];
        for (int i = 0; i < n; i++) {
            popularIds[i] = queue.poll().getKey();
        }
        return popularIds;
    }
}

//Explanation:
//    A HashMap is used to count the occurrences of each show ID in the input array.
//The entries of the HashMap are then added to a PriorityQueue based on their value (i.e., count).
//The PriorityQueue is sorted in descending order by the count of the entries.
//The first n entries are extracted from the PriorityQueue and their keys (i.e., show IDs)
//    are added to the popularIds array.
//Finally, the popularIds array is returned.
//Note: This solution assumes that there are at least n distinct show IDs in the input array.
//    If this is not the case,
//the program may throw a NullPointerException when trying to extract an entry from
//    the PriorityQueue. To handle this case,
//you can add a check to make sure that the size of the PriorityQueue is greater than or equal to n.



    public static int[] findNPopularIdsThroughSortedArray(int[] showIds, int n) {
        HashMap<Integer, Integer> freqMap = new HashMap<>();

        // Count the frequency of each show series id
        for (int id : showIds) {
            freqMap.put(id, freqMap.getOrDefault(id, 0) + 1);
        }

        // Sort the HashMap by frequency in descending order
        List<Map.Entry<Integer, Integer>> freqList = new ArrayList<>(freqMap.entrySet());
        freqList.sort(Collections.reverseOrder(Map.Entry.comparingByValue()));

        // Return the first n keys (show series ids) in the sorted HashMap
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            result[i] = freqList.get(i).getKey();
        }
        return result;
    }
}
